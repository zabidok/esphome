substitutions:
  dev_name: epaper-dash
  temp_host: temp.local
  temp_auth_header: "Basic emFiaWRvazpaYTQ1NjU3OQ=="

esphome:
  name: ${dev_name}
  platformio_options:
    platform: https://github.com/pioarduino/platform-espressif32/releases/download/54.03.21/platform-espressif32.zip
    lib_deps:
      - zinggjm/GxEPD2
    lib_ldf_mode: deep+
    build_flags:
      - -I$PROJECT_PACKAGES_DIR/framework-arduinoespressif32/libraries/Network/src

external_components:
  - source: my_components

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:
  level: INFO

wifi:
  fast_connect: true
  networks:
    - ssid: !secret wifi_ssid_one
      password: !secret wifi_ssid_one_pass
      hidden: true

web_server:
  port: 80
  version: 3

time:
  - platform: sntp
    id: home_time

# Счётчик «висящих» HTTP-ответов (12 штук на полный fetch)
globals:
  - id: http_pending
    type: int
    restore_value: no
    initial_value: '0'

# Видимые в вебе текстовые сенсоры, куда складываем строки state с REST
text_sensor:
  # --- KITCHEN ---
  - platform: template
    id: k_t
    name: "Kitchen Temp"
    icon: mdi:thermometer
  - platform: template
    id: k_h
    name: "Kitchen Hum"
    icon: mdi:water-percent
  - platform: template
    id: k_b
    name: "Kitchen Batt"
    icon: mdi:battery
  - platform: template
    id: k_u
    name: "Kitchen Updated"
    icon: mdi:update

  # --- PLANT ---
  - platform: template
    id: p_t
    name: "Plant Temp"
    icon: mdi:thermometer
  - platform: template
    id: p_h
    name: "Plant Hum"
    icon: mdi:water-percent
  - platform: template
    id: p_b
    name: "Plant Batt"
    icon: mdi:battery
  - platform: template
    id: p_u
    name: "Plant Updated"
    icon: mdi:update

  # --- STREET ---
  - platform: template
    id: s_t
    name: "Street Temp"
    icon: mdi:thermometer
  - platform: template
    id: s_h
    name: "Street Hum"
    icon: mdi:water-percent
  - platform: template
    id: s_b
    name: "Street Batt"
    icon: mdi:battery
  - platform: template
    id: s_u
    name: "Street Updated"
    icon: mdi:update

  # Локальная отметка времени успешного fetch
  - platform: template
    id: last_fetch
    name: "Last Fetch"
    icon: mdi:clock-outline

http_request:
  timeout: 8s
  verify_ssl: false

# Шрифты (для будущего использования в lambda, если понадобится)
font:
  - file: "gfonts://Roboto"
    id: f_title
    size: 22
  - file: "gfonts://Roboto"
    id: f_norm
    size: 18

# Скрипт: тянем все 12 значений, считаем ответы и перерисовываем когда всё готово
script:
  - id: refresh_from_temp
    mode: restart
    then:
      - logger.log: "HTTP: fetch start"
      - lambda: |-
          id(http_pending) = 12;
          ESP_LOGI("http", "pending=%d", id(http_pending));

      # ====================== KITCHEN ======================
      - http_request.get:
          url: !lambda return ("http://" + std::string("${temp_host}") + "/sensor/kitchen_temp").c_str();
          request_headers: 
            Authorization: ${temp_auth_header}
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("http", "k_t status=%d len=%u", response->status_code, (unsigned) body.size());
                  if (response->status_code == 200) {
                    json::parse_json(body, [](JsonObject root) -> bool {
                      if (root["state"]) id(k_t).publish_state(root["state"].as<const char*>());
                      return true;
                    });
                  }
                  id(http_pending)--; ESP_LOGI("http", "pending=%d", id(http_pending));
                  if (id(http_pending) == 0) {
                    char buf[16]; auto t = id(home_time).now();
                    if (t.is_valid()) { t.strftime(buf, sizeof(buf), "%H:%M:%S"); id(last_fetch).publish_state(buf); }
                    else id(last_fetch).publish_state("n/a");
                    ESP_LOGI("http", "fetch done -> redraw"); id(epd).update();
                  }

      - http_request.get:
          url: !lambda return ("http://" + std::string("${temp_host}") + "/sensor/kitchen_hum").c_str();
          request_headers: 
            Authorization: ${temp_auth_header}
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("http", "k_h status=%d len=%u", response->status_code, (unsigned) body.size());
                  if (response->status_code == 200) {
                    json::parse_json(body, [](JsonObject root) -> bool {
                      if (root["state"]) id(k_h).publish_state(root["state"].as<const char*>());
                      return true;
                    });
                  }
                  id(http_pending)--; ESP_LOGI("http", "pending=%d", id(http_pending));
                  if (id(http_pending) == 0) {
                    char buf[16]; auto t = id(home_time).now();
                    if (t.is_valid()) { t.strftime(buf, sizeof(buf), "%H:%M:%S"); id(last_fetch).publish_state(buf); }
                    else id(last_fetch).publish_state("n/a");
                    ESP_LOGI("http", "fetch done -> redraw"); id(epd).update();
                  }

      - http_request.get:
          url: !lambda return ("http://" + std::string("${temp_host}") + "/sensor/kitchen_batt").c_str();
          request_headers: 
            Authorization: ${temp_auth_header}
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("http", "k_b status=%d len=%u", response->status_code, (unsigned) body.size());
                  if (response->status_code == 200) {
                    json::parse_json(body, [](JsonObject root) -> bool {
                      if (root["state"]) id(k_b).publish_state(root["state"].as<const char*>());
                      return true;
                    });
                  }
                  id(http_pending)--; ESP_LOGI("http", "pending=%d", id(http_pending));
                  if (id(http_pending) == 0) {
                    char buf[16]; auto t = id(home_time).now();
                    if (t.is_valid()) { t.strftime(buf, sizeof(buf), "%H:%M:%S"); id(last_fetch).publish_state(buf); }
                    else id(last_fetch).publish_state("n/a");
                    ESP_LOGI("http", "fetch done -> redraw"); id(epd).update();
                  }

      - http_request.get:
          url: !lambda return ("http://" + std::string("${temp_host}") + "/text_sensor/kitchen_update").c_str();
          request_headers: 
            Authorization: ${temp_auth_header}
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("http", "k_u status=%d len=%u", response->status_code, (unsigned) body.size());
                  if (response->status_code == 200) {
                    json::parse_json(body, [](JsonObject root) -> bool {
                      if (root["state"]) id(k_u).publish_state(root["state"].as<const char*>());
                      return true;
                    });
                  }
                  id(http_pending)--; ESP_LOGI("http", "pending=%d", id(http_pending));
                  if (id(http_pending) == 0) {
                    char buf[16]; auto t = id(home_time).now();
                    if (t.is_valid()) { t.strftime(buf, sizeof(buf), "%H:%M:%S"); id(last_fetch).publish_state(buf); }
                    else id(last_fetch).publish_state("n/a");
                    ESP_LOGI("http", "fetch done -> redraw"); id(epd).update();
                  }

      # ====================== PLANT ======================
      - http_request.get:
          url: !lambda return ("http://" + std::string("${temp_host}") + "/sensor/plant_temp").c_str();
          request_headers: 
            Authorization: ${temp_auth_header}
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("http", "p_t status=%d len=%u", response->status_code, (unsigned) body.size());
                  if (response->status_code == 200) {
                    json::parse_json(body, [](JsonObject root) -> bool {
                      if (root["state"]) id(p_t).publish_state(root["state"].as<const char*>());
                      return true;
                    });
                  }
                  id(http_pending)--; ESP_LOGI("http", "pending=%d", id(http_pending));
                  if (id(http_pending) == 0) {
                    char buf[16]; auto t = id(home_time).now();
                    if (t.is_valid()) { t.strftime(buf, sizeof(buf), "%H:%M:%S"); id(last_fetch).publish_state(buf); }
                    else id(last_fetch).publish_state("n/a");
                    ESP_LOGI("http", "fetch done -> redraw"); id(epd).update();
                  }

      - http_request.get:
          url: !lambda return ("http://" + std::string("${temp_host}") + "/sensor/plant_hum").c_str();
          request_headers: 
            Authorization: ${temp_auth_header}
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("http", "p_h status=%d len=%u", response->status_code, (unsigned) body.size());
                  if (response->status_code == 200) {
                    json::parse_json(body, [](JsonObject root) -> bool {
                      if (root["state"]) id(p_h).publish_state(root["state"].as<const char*>());
                      return true;
                    });
                  }
                  id(http_pending)--; ESP_LOGI("http", "pending=%d", id(http_pending));
                  if (id(http_pending) == 0) {
                    char buf[16]; auto t = id(home_time).now();
                    if (t.is_valid()) { t.strftime(buf, sizeof(buf), "%H:%M:%S"); id(last_fetch).publish_state(buf); }
                    else id(last_fetch).publish_state("n/a");
                    ESP_LOGI("http", "fetch done -> redraw"); id(epd).update();
                  }

      - http_request.get:
          url: !lambda return ("http://" + std::string("${temp_host}") + "/sensor/plant_batt").c_str();
          request_headers: 
            Authorization: ${temp_auth_header}
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("http", "p_b status=%d len=%u", response->status_code, (unsigned) body.size());
                  if (response->status_code == 200) {
                    json::parse_json(body, [](JsonObject root) -> bool {
                      if (root["state"]) id(p_b).publish_state(root["state"].as<const char*>());
                      return true;
                    });
                  }
                  id(http_pending)--; ESP_LOGI("http", "pending=%d", id(http_pending));
                  if (id(http_pending) == 0) {
                    char buf[16]; auto t = id(home_time).now();
                    if (t.is_valid()) { t.strftime(buf, sizeof(buf), "%H:%M:%S"); id(last_fetch).publish_state(buf); }
                    else id(last_fetch).publish_state("n/a");
                    ESP_LOGI("http", "fetch done -> redraw"); id(epd).update();
                  }

      - http_request.get:
          url: !lambda return ("http://" + std::string("${temp_host}") + "/text_sensor/plant_update").c_str();
          request_headers: 
            Authorization: ${temp_auth_header}
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("http", "p_u status=%d len=%u", response->status_code, (unsigned) body.size());
                  if (response->status_code == 200) {
                    json::parse_json(body, [](JsonObject root) -> bool {
                      if (root["state"]) id(p_u).publish_state(root["state"].as<const char*>());
                      return true;
                    });
                  }
                  id(http_pending)--; ESP_LOGI("http", "pending=%d", id(http_pending));
                  if (id(http_pending) == 0) {
                    char buf[16]; auto t = id(home_time).now();
                    if (t.is_valid()) { t.strftime(buf, sizeof(buf), "%H:%M:%S"); id(last_fetch).publish_state(buf); }
                    else id(last_fetch).publish_state("n/a");
                    ESP_LOGI("http", "fetch done -> redraw"); id(epd).update();
                  }

      # ====================== STREET ======================
      - http_request.get:
          url: !lambda return ("http://" + std::string("${temp_host}") + "/sensor/street_temp").c_str();
          request_headers: 
            Authorization: ${temp_auth_header}
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("http", "s_t status=%d len=%u", response->status_code, (unsigned) body.size());
                  if (response->status_code == 200) {
                    json::parse_json(body, [](JsonObject root) -> bool {
                      if (root["state"]) id(s_t).publish_state(root["state"].as<const char*>());
                      return true;
                    });
                  }
                  id(http_pending)--; ESP_LOGI("http", "pending=%d", id(http_pending));
                  if (id(http_pending) == 0) {
                    char buf[16]; auto t = id(home_time).now();
                    if (t.is_valid()) { t.strftime(buf, sizeof(buf), "%H:%M:%S"); id(last_fetch).publish_state(buf); }
                    else id(last_fetch).publish_state("n/a");
                    ESP_LOGI("http", "fetch done -> redraw"); id(epd).update();
                  }

      - http_request.get:
          url: !lambda return ("http://" + std::string("${temp_host}") + "/sensor/street_hum").c_str();
          request_headers: 
            Authorization: ${temp_auth_header}
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("http", "s_h status=%d len=%u", response->status_code, (unsigned) body.size());
                  if (response->status_code == 200) {
                    json::parse_json(body, [](JsonObject root) -> bool {
                      if (root["state"]) id(s_h).publish_state(root["state"].as<const char*>());
                      return true;
                    });
                  }
                  id(http_pending)--; ESP_LOGI("http", "pending=%d", id(http_pending));
                  if (id(http_pending) == 0) {
                    char buf[16]; auto t = id(home_time).now();
                    if (t.is_valid()) { t.strftime(buf, sizeof(buf), "%H:%M:%S"); id(last_fetch).publish_state(buf); }
                    else id(last_fetch).publish_state("n/a");
                    ESP_LOGI("http", "fetch done -> redraw"); id(epd).update();
                  }

      - http_request.get:
          url: !lambda return ("http://" + std::string("${temp_host}") + "/sensor/street_batt").c_str();
          request_headers: 
            Authorization: ${temp_auth_header}
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("http", "s_b status=%d len=%u", response->status_code, (unsigned) body.size());
                  if (response->status_code == 200) {
                    json::parse_json(body, [](JsonObject root) -> bool {
                      if (root["state"]) id(s_b).publish_state(root["state"].as<const char*>());
                      return true;
                    });
                  }
                  id(http_pending)--; ESP_LOGI("http", "pending=%d", id(http_pending));
                  if (id(http_pending) == 0) {
                    char buf[16]; auto t = id(home_time).now();
                    if (t.is_valid()) { t.strftime(buf, sizeof(buf), "%H:%M:%S"); id(last_fetch).publish_state(buf); }
                    else id(last_fetch).publish_state("n/a");
                    ESP_LOGI("http", "fetch done -> redraw"); id(epd).update();
                  }

      - http_request.get:
          url: !lambda return ("http://" + std::string("${temp_host}") + "/text_sensor/street_update").c_str();
          request_headers: 
            Authorization: ${temp_auth_header}
          capture_response: true
          on_response:
            then:
              - lambda: |-
                  ESP_LOGI("http", "s_u status=%d len=%u", response->status_code, (unsigned) body.size());
                  if (response->status_code == 200) {
                    json::parse_json(body, [](JsonObject root) -> bool {
                      if (root["state"]) id(s_u).publish_state(root["state"].as<const char*>());
                      return true;
                    });
                  }
                  id(http_pending)--; ESP_LOGI("http", "pending=%d", id(http_pending));
                  if (id(http_pending) == 0) {
                    char buf[16]; auto t = id(home_time).now();
                    if (t.is_valid()) { t.strftime(buf, sizeof(buf), "%H:%M:%S"); id(last_fetch).publish_state(buf); }
                    else id(last_fetch).publish_state("n/a");
                    ESP_LOGI("http", "fetch done -> redraw"); id(epd).update();
                  }

button:
  - platform: template
    name: "Refresh (redraw only)"
    on_press:
      - component.update: epd

  - platform: template
    name: "Fetch from temp + redraw"
    on_press:
      - script.execute: refresh_from_temp

display:
  - platform: my_gxepd2
    id: epd
    width: 400
    height: 300
    sck_pin: 13
    mosi_pin: 14
    miso_pin: -1
    cs_pin: 15
    dc_pin: 27
    reset_pin: 26
    busy_pin: 25
    update_interval: never
